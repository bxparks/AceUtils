<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AceUtils: Mode Group</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AceUtils
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
   <div id="projectbrief">Useful Arduino utilties which are too small as separate libraries, but complex enough to be shared among multiple projects, and often have external dependencies to other libraries.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Mode Group </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Deprecated</b>: The <code><a class="el" href="mode__group_8h_source.html">mode_group.h</a></code> header and its <code>ModeGroup</code> and <code>ModeNavigator</code> are deprecated. This was an attempt to encode the UI transitions of a small application (e.g. a clock with an LCD or LED display, and some buttons) in a way that was data driven. The alternative was to use a series of switch-statements that dispatched to short code fragments to handle external events (such as button presses, and periodic clock signals). It turned out that while using switch-statements seemed simplistic and verbose, it was far easier to understand and maintain compared to the <code>ModeGroup</code> and <code>ModeNavigator</code> framework which became difficult to understand after a few months away from the code. I think this is another example where simple and verbose code wins over clever code because the execution path of the simple code is explicit and easier to follow.</p>
<p>The <code>ModeGroup</code> struct defines a tree of sibling and parent/child modes which define the different modes of a clock that can be controlled by 2 buttons.</p>
<ul>
<li>Clicking the Mode button causes the current mode to change among the sibling modes of the current <code>ModeGroup</code>.</li>
<li>Long Pressing the Mode button toggle between the root ModeGroup and a child ModeGroup of the current mode.<ul>
<li>For example, if the current mode is a "view" mode, a LongPress will cause it to go into one of the "change" modes.</li>
<li>A subsequent LongPress goes back to the previous view mode.</li>
</ul>
</li>
</ul>
<p>The <code>ModeNavigator</code> extracts common navigation code to promote code reuse.</p>
<p>The advantage of using these classes is that the hierarchy of modes is data-driven instead of being hardcoded into various <code>switch</code> statements. It is far easier to rearrange the UI of the clock, placing modes in different order, or at different levels, using a data-driven specification. When the navigation was in code, it was quite difficult to make changes without spending a lot of time fixing subtle UI bugs.</p>
<p>This package is used by:</p>
<ul>
<li><a href="https://github.com/bxparks/clocks/tree/master/OneZoneClock">OneZoneClock</a></li>
<li><a href="https://github.com/bxparks/clocks/tree/master/MultiZoneClock">MultiZoneClock</a></li>
<li><a href="https://github.com/bxparks/clocks/tree/master/WorldClock">WorldClock</a></li>
<li><a href="https://github.com/bxparks/clocks/tree/master/MedMinder">MedMinder</a></li>
</ul>
<h1>Usage</h1>
<p>(Don't have the energy to write a full documentation of how to use this library. I wrote some notes to myself below because I had trouble remembering how this worked, but it's mostly for my own benefit. The next best thing is to look at the source code for one of the above clocks.)</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;AceUtils.h&gt;</div>
<div class="line">#include &lt;mode_group/mode_group.h&gt;</div>
<div class="line">using ace_utils::mode_group::ModeGroup;</div>
<div class="line">using ace_utils::mode_group::ModeRecord;</div>
<div class="line">using ace_utils::mode_group::ModeNavigator;</div>
</div><!-- fragment --><p>The <code>ModeRecord</code> is a UI rendering mode, arranged in a hierarchical tree. It contains a <code>modeId</code> that uniquely identifies the mode, and a nullable <code>ModeGroup</code> pointer containing the children of this particular mode.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">struct ModeRecord {</div>
<div class="line">  /** Unique integer identifier of the mode. */</div>
<div class="line">  uint8_t const modeId;</div>
<div class="line"> </div>
<div class="line">  /** ModeGroup containing children ModeRecords. Null if no children. */</div>
<div class="line">  const ModeGroup* const childGroup;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>ModeGroup</code> is an array of <code>ModeRecords</code> and a pointer back to the parent <code>ModeGroup</code>.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">struct ModeGroup {</div>
<div class="line">  /** Pointer to the parent ModeGroup. Set to nullptr for the root group. */</div>
<div class="line">  const ModeGroup* const parentGroup;</div>
<div class="line"> </div>
<div class="line">  /** Number of modes. */</div>
<div class="line">  uint8_t const numModes;</div>
<div class="line"> </div>
<div class="line">  /** Array of children mode groups. */</div>
<div class="line">  const ModeRecord* const children;</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Defining the Hierarchy</h2>
<p>The tree hierarchy should be defined starting from the bottom leaf ModeRecords up to the root ModeGroup. A single <code>rootModeGroup</code> needs to be defined. Since each <code>ModeGroup</code> contains a pointer up to the parent, it is sometimes necessary to define the parent with an <code>extern</code> statement to resolve the forward reference.</p>
<p>For example, here is a UI hierarchy where a SingleClick of the Mode button cycles through the siblings in the tree. But a LongPress of the Mode button causes the UI to move down to the child, or move up to the parent if already at the child: </p><div class="fragment"><div class="line">- View DateTime</div>
<div class="line">   - Change hour</div>
<div class="line">   - Change minute</div>
<div class="line">   - Change second</div>
<div class="line">   - Change day</div>
<div class="line">   - Change month</div>
<div class="line">   - Change year</div>
<div class="line">- View TimeZone</div>
<div class="line">   - Change zone name</div>
<div class="line">- Settings</div>
<div class="line">   - Change contrast</div>
<div class="line">   - Invert display</div>
<div class="line">- View SystemClock</div>
<div class="line">- About</div>
</div><!-- fragment --><p>The <code>ModeGroup</code> and <code>ModeRecord</code> definition looks something like this (see <a href="https://github.com/bxparks/clocks/blob/master/OneZoneClock/OneZoneClock.ino">clocks/OneZoneClock/OneZoneClock.ino</a></p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">extern const ModeGroup ROOT_MODE_GROUP;</div>
<div class="line"> </div>
<div class="line">// List of DateTime modes.</div>
<div class="line">const ModeRecord DATE_TIME_MODES[] = {</div>
<div class="line">  {(uint8_t) Mode::kChangeYear, nullptr},</div>
<div class="line">  {(uint8_t) Mode::kChangeMonth, nullptr},</div>
<div class="line">  {(uint8_t) Mode::kChangeDay, nullptr},</div>
<div class="line">  {(uint8_t) Mode::kChangeHour, nullptr},</div>
<div class="line">  {(uint8_t) Mode::kChangeMinute, nullptr},</div>
<div class="line">  {(uint8_t) Mode::kChangeSecond, nullptr},</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// List of TimeZone modes.</div>
<div class="line">const ModeRecord TIME_ZONE_MODES[] = {</div>
<div class="line">  {(uint8_t) Mode::kChangeTimeZoneName, nullptr},</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// List of Settings modes.</div>
<div class="line">const ModeRecord SETTINGS_MODES[] = {</div>
<div class="line">  {(uint8_t) Mode::kChangeSettingsContrast, nullptr},</div>
<div class="line">  {(uint8_t) Mode::kChangeInvertDisplay, nullptr},</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// ModeGroup for the DateTime modes.</div>
<div class="line">const ModeGroup DATE_TIME_MODE_GROUP = {</div>
<div class="line">  &amp;ROOT_MODE_GROUP /* parentGroup */,</div>
<div class="line">  sizeof(DATE_TIME_MODES) / sizeof(ModeRecord),</div>
<div class="line">  DATE_TIME_MODES</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// ModeGroup for the TimeZone modes.</div>
<div class="line">const ModeGroup TIME_ZONE_MODE_GROUP = {</div>
<div class="line">  &amp;ROOT_MODE_GROUP /* parentGroup */,</div>
<div class="line">  sizeof(TIME_ZONE_MODES) / sizeof(ModeRecord),</div>
<div class="line">  TIME_ZONE_MODES</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// ModeGroup for the Settings modes.</div>
<div class="line">const ModeGroup SETTINGS_MODE_GROUP = {</div>
<div class="line">  &amp;ROOT_MODE_GROUP /* parentGroup */,</div>
<div class="line">  sizeof(SETTINGS_MODES) / sizeof(ModeRecord),</div>
<div class="line">  SETTINGS_MODES</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// List of top level modes.</div>
<div class="line">const ModeRecord TOP_LEVEL_MODES[] = {</div>
<div class="line">  {(uint8_t) Mode::kViewDateTime, &amp;DATE_TIME_MODE_GROUP},</div>
<div class="line">  {(uint8_t) Mode::kViewTimeZone, &amp;TIME_ZONE_MODE_GROUP},</div>
<div class="line">  {(uint8_t) Mode::kViewSettings, &amp;SETTINGS_MODE_GROUP},</div>
<div class="line">  {(uint8_t) Mode::kViewSysclock, nullptr},</div>
<div class="line">  {(uint8_t) Mode::kViewAbout, nullptr},</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Root mode group</div>
<div class="line">const ModeGroup ROOT_MODE_GROUP = {</div>
<div class="line">  nullptr /* parentGroup */,</div>
<div class="line">  sizeof(TOP_LEVEL_MODES) / sizeof(ModeRecord),</div>
<div class="line">  TOP_LEVEL_MODES</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>ModeNavigator</code> is a class that traverses this tree hierarchy given a pointer to the root <code>ModeGroup</code>:</p>
<div class="fragment"><div class="line">class ModeNavigator {</div>
<div class="line">  public:</div>
<div class="line">    ModeNavigator(ModeGroup const* rootModeGroup);</div>
<div class="line"> </div>
<div class="line">    /** Return the modeId of the current position. */</div>
<div class="line">    uint8_t modeId() const { return mModeId; }</div>
<div class="line"> </div>
<div class="line">    /** Change to the next sibling Mode. */</div>
<div class="line">    void changeMode();</div>
<div class="line"> </div>
<div class="line">    /** Go up or down the ModeGroup hierarchy. */</div>
<div class="line">    void changeGroup();</div>
<div class="line">};</div>
</div><!-- fragment --><p>Currently the <code>changeGroup()</code> method supports only a 2-level hierarchy. If the number of levels in the tree becomes more than 2, then we need to add <code>upGroup()</code> and a <code>downGroup()</code> methods.</p>
<h2>Alternatives Considered</h2>
<p>I tried creating a tree hierarchy using the traditional <code>File</code> and <code>Directory</code> metaphor, like this:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">struct ModeNode {</div>
<div class="line">  ModeNode* parent;</div>
<div class="line">  uint8_t modeId;</div>
<div class="line">  uint8_t numChildren;</div>
<div class="line">  ModeNode* children;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The problem with this data structure was that it seemed impossible to create this recursive data structure statically, at compile time, because both the <code>parent</code> and the <code>children</code> needed to be defined for each node.</p>
<p>We could try to create the bare nodes, then use a <code>setup()</code> method to create the links between nodes. But the problem with that is that the number of children in each node is not determined at compiled time, so each node would require a dynamically resizable array of <code>ModeNode*</code> elements.</p>
<p>It occurs to me that it might be possible to use a doubly-linked list of sibling nodes to avoid dynamic resizing. But I didn't want to spend much time on this. The data structure described above collects all the siblings into a single <code>ModeGroup</code> structure at compile-time, so it avoids having to call a <code>setup()</code> function at the start of the application.</p>
<p>Anyway, I consider this to be a fairly big hack that works for me. Not really fit for production use. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
