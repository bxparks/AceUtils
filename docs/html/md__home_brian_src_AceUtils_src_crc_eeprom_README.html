<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AceUtils: CRC EEPROM</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AceUtils
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
   <div id="projectbrief">Useful Arduino utilties which are too small as separate libraries, but complex enough to be shared among multiple projects, and often have external dependencies to other libraries.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">CRC EEPROM </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Save data to EEPROM along with a CRC32 value, and an optional <code>contextId</code>. When the data is retrieved, the CRC32 is calculated and compared with the expected CRC32. The <code>contextId</code> is also compared with the expected contextId to verify that the data came from the same application.</p>
<h1>Examples</h1>
<ul>
<li><a href="../../examples/CrcEepromDemo">examples/CrcEepromDemo</a></li>
</ul>
<h1>Usage</h1>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;Arduino.h&gt;</div>
<div class="line">#include &lt;AceUtils.h&gt;</div>
<div class="line">#include &lt;crc_eeprom/crc_eeprom.h&gt;</div>
<div class="line">using ace_utils::crc_eeprom::toContextId;</div>
<div class="line">using ace_utils::crc_eeprom::CrcEepromAvr;</div>
<div class="line">using ace_utils::crc_eeprom::CrcEepromEsp;</div>
<div class="line"> </div>
<div class="line">// The contextId can be anything you want, and should uniquely identify the</div>
<div class="line">// application to avoid collisions with another applications that store data</div>
<div class="line">// with the same length.</div>
<div class="line">const uint32_t CONTEXT_ID = 0x664cb683;</div>
<div class="line"> </div>
<div class="line">#if defined(EPOXY_DUINO)</div>
<div class="line">  #include &lt;EpoxyEepromEsp.h&gt;</div>
<div class="line">  CrcEepromEsp&lt;EpoxyEepromEsp&gt; crcEeprom(EspStyleEepromInstance, CONTEXT_ID);</div>
<div class="line"> </div>
<div class="line">#elif defined(ESP8266) || defined(ESP32)</div>
<div class="line">  #include &lt;EEPROM.h&gt;</div>
<div class="line">  CrcEepromEsp&lt;EEPROMClass&gt; crcEeprom(EEPROM, CONTEXT_ID);</div>
<div class="line"> </div>
<div class="line">#elif defined(ARDUINO_ARCH_STM32)</div>
<div class="line"> </div>
<div class="line">  // Use this for STM32. The &#39;buffered_eeprom_stm32&#39; library provides</div>
<div class="line">  // the BufferedEEPROM object which internally uses the buffered versions of</div>
<div class="line">  // the low-level eeprom functions. The BufferedEEPROM object implements the</div>
<div class="line">  // ESP-flavored EEPROM API.</div>
<div class="line">  #include &lt;AceUtils.h&gt;</div>
<div class="line">  #include &lt;buffered_eeprom_stm32/buffered_eeprom_stm32.h&gt;</div>
<div class="line">  CrcEepromEsp&lt;BufferedEEPROMClass&gt; crcEeprom(BufferedEEPROM, CONTEXT_ID);</div>
<div class="line"> </div>
<div class="line">  // Don&#39;t do this for STM32 because the default EEPROM flashes the entire</div>
<div class="line">  // page for *every* byte!</div>
<div class="line">  //#include &lt;EEPROM.h&gt;</div>
<div class="line">  //CrcEepromAvr&lt;EEPROMClass&gt; crcEeprom(EEPROM, CONTEXT_ID);</div>
<div class="line"> </div>
<div class="line">#else</div>
<div class="line">  // Assume AVR-style EEPROM for all other cases.</div>
<div class="line">  #include &lt;EEPROM.h&gt;</div>
<div class="line">  CrcEepromAvr&lt;EEPROMClass&gt; crcEeprom(EEPROM, CONTEXT_ID);</div>
<div class="line"> </div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">void setupEeprom() {</div>
<div class="line">#if defined(EPOXY_DUINO)</div>
<div class="line">  EpoxyEepromEspInstance.begin(1024);</div>
<div class="line">#elif defined(ESP8266) || defined(ESP32)</div>
<div class="line">  EEPROM.begin(256);</div>
<div class="line">#elif defined(ARDUINO_ARCH_STM32)</div>
<div class="line">  BufferedEEPROM.begin();</div>
<div class="line">#else</div>
<div class="line">  // Assume AVR style EEPOM and do nothing.</div>
<div class="line">#endif</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct StoredInfo {</div>
<div class="line">  [...]</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">StoredInfo storedInfo;</div>
<div class="line"> </div>
<div class="line">const uint16_t EEPROM_ADDRESS = 0;</div>
<div class="line"> </div>
<div class="line">void setup() {</div>
<div class="line">  Serial.begin(115200);</div>
<div class="line">  while (!Serial);</div>
<div class="line"> </div>
<div class="line">  setupEeprom();</div>
<div class="line"> </div>
<div class="line">  // Write to EEPROM w/ CRC and contextId check.</div>
<div class="line">  size_t writtenSize = crcEeprom.writeWithCrc(EEPROM_ADDRESS, storedInfo);</div>
<div class="line">  if (!writtenSize) {</div>
<div class="line">    Serial.println(&quot;Error writing to EEPROM&quot;);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // Read from EEPROM w/ CRC and contextId check.</div>
<div class="line">  bool status = crcEeprom.readWithCrc(EEPROM_ADDRESS, storedInfo);</div>
<div class="line">  if (!status) {</div>
<div class="line">    Serial.println(&quot;Error reading from EEPROM&quot;);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void loop() {</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Context ID</h2>
<p>The <code>contextId</code> is a 32-bit identifier that is designed to help collisions between 2 applications which store different data, but with the <b>same</b> size. Since the size of the data is the same, the CRC will be valid, but the 2 applications will certain not have compatible data. The <code>writeWithCrc()</code> writes this <code>contextId</code> into the EEPROM, just like the CRC. The <code>readWithCrc()</code> verifies that the <code>contextId</code> matches, just like the CRC.</p>
<p>You can generate the <code>contextId</code> in using any method. I wrote the <code>CrcEeprom::toContextId()</code> helper function to convert 4-letter sequences (e.g. 'o', 'c', 'l', 'k') into a 32-bit number. But I found it difficult to create new 4-letter combos which don't collide with each other.</p>
<p>I now recommend that you simply use a 32-bit random number generator to get the <code>contextId</code>. Here are some sources:</p>
<ul>
<li>Linux<ul>
<li><code>$ od -v -An -N4 -t x4 /dev/urandom</code></li>
<li>You have to add the "0x" prefix manually.</li>
</ul>
</li>
<li>Bash<ul>
<li><code>$ printf "0x%08x\n" $(($RANDOM * 65536 + $RANDOM))</code></li>
<li>The range of <code>$RANDOM</code> is only 15-bits, so this generates only a 30-bit random number instead of 32. This may be good enough for you.</li>
</ul>
</li>
<li>Python<ul>
<li><code>$ python3 -c 'import random; print(f"0x{random.randint(0,2**32-1):08x}")</code></li>
</ul>
</li>
<li>Perl<ul>
<li>&lsquo;$ perl -e 'printf("0x%08x\n", int(rand(2**32)))&rsquo;`</li>
</ul>
</li>
<li>Awk<ul>
<li>&lsquo;$ awk 'BEGIN{ srand(); printf("0x%08x\n", int(rand() * 2**32)) }&rsquo;<code></code></li>
<li><code>If you don't use</code>srand()`, you get the same number every time you run this.</li>
<li>If you use <code>srand()</code> within the same second, you will get the same number.</li>
</ul>
</li>
<li>Online web generators<ul>
<li>It was actually difficult to find online random generators for this purpose. Here are some:</li>
<li><a href="https://onlinerandomtools.com/generate-random-hexadecimal-numbers">https://onlinerandomtools.com/generate-random-hexadecimal-numbers</a></li>
<li><a href="https://numbergenerator.org/hex-code-generator">https://numbergenerator.org/hex-code-generator</a></li>
</ul>
</li>
</ul>
<h2>Template Classes</h2>
<p>A previous version of this used a <code>EepromInterface</code> pure abstract class that provides a stable API to the <code>CrcEeprom</code> class. Two subclasses were <code>AvrStyleEeprom</code> and <code>EspStyleEeprom</code>. Converting <code>CrcEeprom</code> to a template class, templatized on <code>AvrStyleEeprom</code> and <code>EspStyleEeprom</code> eliminates the virtual function calls, and seems to save between 150 to 950 bytes of flash memory on AVR processors. On small processors, like the ATtiny85, this seemed like an optimization worth making.</p>
<p>The complexity of <code>CrcEeprom&lt;&gt;</code> has been reduced by creating the following helper classes:</p>
<ul>
<li><code>CrcEepromAvr&lt;E&gt;</code></li>
<li><code>CrcEepromEsp&lt;E&gt;</code></li>
</ul>
<p>New EEPROM implementations can be with with <code>CrcEeprom</code> by creating a new instance of the <code>EepromInterface</code>, then using the raw <code>CrcEeprom</code> template class. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
